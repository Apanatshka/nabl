module coq/main

imports
	libstrc
	libstratego-gpp
  util/src-gen
  analysis/normalize
  analysis/signatures
    
  // NaBL2 imports:
  signatures/nabl2/shared/common/-
  signatures/nabl2/shared/constraints/-
  signatures/common/-
  signatures/signatures/-
  signatures/rules/-
  
  // Coq imports:
  coq/analysis/explicate-wildcards
  coq/analysis/dependencies
  coq/util/maybe-list
  coq/util/mbind-err
  coq/query
  signatures/Vernacular-sig
  signatures/Gallina-sig
  signatures/Options-sig
  
  // Coq pp
	pp/Coq-parenthesize
	pp/Coq-pp

rules // Constant(s)

	coq-list-name = !"list"
	
	cgref         = !"scopeofRef"
	cgdecl        = !"scopeofDecl"
	cresolve      = !"rlookup"
	ctypeof       = !"typofDecl"
	cgdirectedge  = !"edgeofScope"
	
	p-edge        = !"P"
	
	get-occ       = !"getOccurrence"

rules

  generate-coq:
    (_, _, ast, path, project-path) -> (filename, result)
    with
    	Module(name, decls) := ast;
      filename := <create-src-gen(|project-path, "nabl2", ".v")> name;
      // Pre-processing
      decls' := <explicate-wildcards> decls;
      imps := <filter(?Imports(<id>)); concat> decls';
      sigs := <filter(?Signature(<id>)); concat> decls';
      ruls := <filter(?Rules(<id>)); concat> decls';
      result :=
      	//  Calculate dependencies between constraint generation rules
      	<mdeps;
      	mbind(\ deps ->
	      // Generate syntax and rule types based on signatures
	     	<sigs-to-coq;
	      mbind(\ coq_defs ->
	     	// Augment definitions with generated rules
	     	<rules-to-coq;
	     	mbind(\ coq_defs' ->
	    	// Transform based on dependencies between rules (definition-before-use)
	     	<foldl(\
	    		((x, y), coq2) ->
	    			<join-induc-defs> (x, y, coq2) \);
	    	mbind(\ coq1 ->
	    	// Pretty-print
	    	<parenthesize-Coq; prettyprint-Coq; box2text-string(|100)> coq1
	    	\)> (<concat> deps, coq_defs')
	     	\)> (ruls, coq_defs) \)> sigs \)> ruls

rules // Signatures

	sigs-to-coq:
		sigs -> <sigs-to-coql; concat> sigs

	sigs-to-coql:
 		[x|xs] ->
 			<sig-to-coq;
 			mbind(\ y ->
 			<sigs-to-coql;
 			mbind(\ xs' ->
 			<cons-if-some> (y, xs') \)> xs \)> x
 	
 	sigs-to-coql:
 		[] -> []
 	
 	sig-to-coq:
 		CGen(cs) ->
 			<cgen-sigs-to-coq> cs
 	
 	sig-to-coq:
 		Types(ts) ->
 			<type-sigs-to-coq;
 			mbind(\ ts' ->
 			[Inductive([Induc("GroupByTypeHere", None(), Type(),
 				ListDeclBar(ts'))])] \)> ts

 	sig-to-coq(|deps):
 		x ->
 			<concat-strings; err> ["Encountered an unexpected declaration: ",
 				<write-to-string> x, ". Please report."]
 		where
 			not(?CGen(_) <+ ?Types(_))

rules	// Constraint generation signatures

	cgen-sigs-to-coq:
		[csig|csigs] ->
			<cgen-sig-to-coq;
			mbind(\ coqsig' ->
			<cgen-sigs-to-coq;
			mbind(\ coqsigs' ->
			<cons-if-some> (coqsig', coqsigs')
			\)> csigs \)> csig

	cgen-sigs-to-coq:
		[] -> []

	cgen-sig-to-coq:
		CGenSig(name, trsort, ssorts, tysort) ->
			x''
			with
			x'':=
			<get-name;
				mbind(\ name' ->
				<postify-term-sort;
				mbind(\ trsort' ->
				<term-sort-to-coq;
				mbind(\ trsort'' ->
//				<append-if-some; foldr(!Prop(),
//					\ (x, y) ->
//						<mbind(\ y' ->
//						<type-sort-to-coq;
//						mbind(\ x' ->
//						Arrow(x', y')
//						\)> x \)> y \);
//				mbind(\ srts' ->
				Inductive([Induc(<cgen-rename> name', None(),
					Arrow(trsort'', Prop()), None())])
//					\)> (ssorts, tysort)
					\)> trsort'
					\)> trsort
					\)> name
	
	cgen-sig-to-coq:
		x ->
			<concat-strings; err> ["Encountered an unexpected constraint generation signature: ",
				<write-to-string> x, ". Please report."]
		where
			not(?CGenSig(_, _, _, _))

rules // Type signatures

	type-sigs-to-coq:
		[tsig|tsigs] ->
			<type-sig-to-coq;
				mbind(\ y ->
				<type-sigs-to-coq;
				mbind(\ tsigs' ->
				<cons-if-some> (y, tsigs') \)> tsigs \)> tsig

	type-sigs-to-coq:
		[] -> []

  type-sig-to-coq:
    TypeSig(tname, tparams) -> 
			<foldr(!Ref(<type-sort;type-sort-to-coq>),
					\ (x, y) ->
						<mbind(\ z ->
						<type-sort-to-coq;
						mbind(\ x' ->
						Arrow(x', z)
						\)> x \)> y \);
			mbind(\ t ->
			ConsDecl(tname, None(),
				OptType(t)) \)> tparams

rules // NaBL2 sorts

	type-sort-to-coq:
		SortNoArgs(name) -> Ref(name)
	
	type-sort-to-coq:
		"s" -> Ref("ScopeId")

	type-sort-to-coq:
		x ->
			<concat-strings; err> ["Encountered an unexpected type sort: ", <write-to-string> x, ". Please report."]
	where
		not(?SortNoArgs(_) <+ ?"s")
	
	term-sort-to-coq:
		SortNoArgs(name) ->
			Ref(name)
	
	term-sort-to-coq:
		Sort("List", [sort]) ->
			Apply(Ref(<coq-list-name>), <term-sort-to-coq> sort)
	
	term-sort-to-coq:
		x ->
			<concat-strings; err> ["Encountered an unexpected term sort: ", <write-to-string> x, ". Please report."]
		where
			not(?SortNoArgs(_) <+ ?Sort("List", [_]))

rules // Rules

	rules-to-coq:
		([r|rs], coq) ->
			<rule-to-coq;
			mbind(\ coq' ->
			<rules-to-coq> (rs, coq') \)> (r, coq)
	
	rules-to-coq:
		([], coq) -> coq

	// Ignored, for now...
	rule-to-coq:
		(CGenInitRule(spattern, tpattern, body), coq) ->
			coq
		
	rule-to-coq:
		(CGenMatchRule(name, trpattern, spattern, typattern, body), coq) ->
			<rule-name-from-term-pattern;
			mbind(\ rname ->
			<term-pattern-to-coq;
			mbind(\ trpattern' ->
			<get-name;
			mbind(\ cgen_name ->
			<scope-patterns-to-coq;
			mbind(\ spattern' ->
			<type-pattern-to-coq;
			mbind(\ typattern' ->
			<cgen-body-to-coq;
			mbind(\ body' ->
			<alltd(\
			Induc(coq_name, x, ty, cs) ->
				Induc(coq_name, x, ty,
					<append-constructor>
						(cs, ConsDecl(rname,
							None(), // Binders -- FIXME
							OptType(
								<foldr(
								  !
									Apply(Ref(coq_name),
										<foldr(!Ref(post_c),
											\ (x, y) -> Apply(y, x) \)>
												[trpattern', typattern'|<reverse> spattern']),
									\ (x, y) -> ArrowLn(x, y) \)> body'))))
				where
					<equal> (<cgen-rename> cgen_name, coq_name);
					Arrow(Ref(post_sort), Prop()) := ty;
					post_c := <rename-post-sort-to-post-constructor> post_sort
				 \)> coq
			\)> body
			\)> typattern
			\)> spattern
			\)> name
			\)> trpattern
			\)> (name, trpattern)
	
	rule-to-coq(|sigs):
		(r, _) -> 
			<concat-strings; err>
				["Encountered an unexpected rule kind: ",
					<write-to-string> r, ". Please report."]
		where
			not(!r;
				?CGenInitRule(_, _, _) <+
				?CGenMatchRule(_, _, _, _, _))

	// Converts a None() to a ListDeclBar if necessary,
	// and appends the constructor
	append-constructor:
		(None(), c) ->
			ListDeclBar([c])

	append-constructor:
		(ListDeclBar(cs), c) ->
			ListDeclBar(<conc> (cs, [c]))

rules // Rule naming

	rule-name-from-term-pattern:
		(rname, Op(cname, _)) ->
			<get-name;
			mbind(\ name -> 
			<conc-strings> (name, cname)
			\)> rname
			
	rule-name-from-term-pattern:
		(rname, List([])) ->
			<get-name;
			mbind(\ name ->
			<conc-strings> (name, "Nil")
			\)> rname
			
	rule-name-from-term-pattern:
		(rname, List([_|_])) ->
			<get-name;
			mbind(\ name ->
			<conc-strings> (name, "Cons")
			\)> rname
	
	rule-name-from-term-pattern:
		(rname, ListTail(_, _)) ->
			<get-name;
			mbind(\ name ->
			<conc-strings> (name, "Cons")
			\)> rname
	
	rule-name-from-term-pattern:
		(rname, x) ->
			<concat-strings; err>
				["Encountered an unexpected term kind during rule name generation: ",
					<write-to-string> x, ". Please report."]
		where
			not(!x;
				?Op(_, _) <+
				?List([]) <+
				?List([_|_]) <+
				?ListTail)

rules // Term patterns

	term-pattern-to-coq:
		Op(cname, params) ->
			<reverse; foldr(!Ref(cname),
				\ (param, coq_term) ->
					Apply(coq_term, <term-pattern-to-coq> param) \)> params
	
	term-pattern-to-coq:
		List(lst) ->
			<list-pattern-to-coq> lst
			
	term-pattern-to-coq:
		ListTail(heads, tail) ->
			<conc; list-pattern-to-coq> (heads, [tail])
	
	term-pattern-to-coq:
		Var(x) -> Ref(x)
	
	term-pattern-to-coq:
		x ->
			<concat-strings; err>
				["Encountered an unexpected term: ",
					<write-to-string> x, ". Please report."]
		where
			not(?Op(_, _) <+
				?List(_) <+
				?ListTail(_, _) <+
				?Var(_))

rules // Scope patterns

	scope-patterns-to-coq:
		List(sps) ->
			<scope-pattern-list-to-coq> sps

	scope-pattern-list-to-coq:
		[sp|sps] ->
			<scope-pattern-to-coq;
			mbind(\ sp' ->
			<scope-pattern-list-to-coq;
			mbind(\ sps' ->
			[sp'|sps']
			\)> sps
			\)> sp
	
	scope-pattern-list-to-coq:
		[] -> []

	scope-pattern-to-coq:
		Var(s) -> Ref(s)

	scope-pattern-to-coq:
		x ->
			<concat-strings; err>
				["Encountered an unexpected scope annotation: ",
					<write-to-string> x, ". Please report."]
		where
			(?Var(_))

rules // Type pattern

	type-pattern-to-coq:
		Type(x) ->
			<term-pattern-to-coq> x
	
	type-pattern-to-coq:
		x ->
			<concat-strings; err>
				["Encountered an unexpected type annotation: ",
					<write-to-string> x, ". Please report."]

rules // CGen body

	cgen-body-to-coq:
		[c|cs] ->
			x with x:=
			<cgen-clause-to-coq;
			mbind(\ c' ->
			<cgen-body-to-coq;
			mbind(\ cs' ->
			<conc-if-some> (c', cs')
			\)> cs
			\)> c

	cgen-body-to-coq:
		[] -> []

	cgen-clause-to-coq:
		CTrue() -> None()
		
	cgen-clause-to-coq:
		CGRef(occ, s) ->
			<occurrence-to-coq;
			mbind(\ occ' ->
			<term-pattern-to-coq;
			mbind(\ s' ->
			[Apply(Apply(Ref(<cgref>), occ'), s')]
			\)> s
			\)> occ

	cgen-clause-to-coq:
		CGDecl(occ, s) ->
			<occurrence-to-coq;
			mbind(\ occ' ->
			<term-pattern-to-coq;
			mbind(\ s' ->
			[Apply(Apply(Ref(<cgdecl>), occ'), s')]
			\)> s
			\)> occ

	
	cgen-clause-to-coq:
		CResolve(occ1, occ2, _) ->
			<occurrence-to-coq;
			mbind(\ occ1' ->
			<occurrence-to-coq;
			mbind(\ occ2' ->
			[Apply(Apply(Ref(<cresolve>), occ1'), occ2')]
			\)> occ2
			\)> occ1 
			
	cgen-clause-to-coq:
		CTypeOf(occ, t, _, _) ->
			<occurrence-to-coq;
			mbind(\ occ' ->
			<term-pattern-to-coq;
			mbind(\ t' ->
			[Apply(Apply(Ref(<ctypeof>), occ'), t')]
			\)> t
			\)> occ
	
	cgen-clause-to-coq:
		CGenRecurse(name, trpattern, spatterns, typattern) ->
			<get-name;
			mbind(\ name' ->
			<term-pattern-to-coq;
			mbind(\ trpattern' ->
			<scope-patterns-to-coq;
			mbind(\ spatterns' ->
			<type-pattern-to-coq;
			mbind(\ typattern' ->
			[Apply(Ref(<cgen-rename> name'), trpattern'),
			Parenthetical(Eq(Apply(Ref(<conc-strings> ("proj_", name')), trpattern'),
				<foldr(!Ref("nil"),
					\ (x, y) -> Apply(Apply(Ref("cons"), x), y) \)>
				<conc> (spatterns', [typattern'])))]
			\)> typattern
			\)> spatterns
			\)> trpattern
			\)> name
	
	cgen-clause-to-coq:
		CGDirectEdge(s1, lbl, s2) ->
			<term-pattern-to-coq;
			mbind(\ s1' ->
			<label-pattern-to-coq;
			mbind(\ lbl' ->
			<term-pattern-to-coq;
			mbind(\ s2' ->
			[Apply(Apply(Apply(Ref(<cgdirectedge>), s1'), lbl'), s2')]
			\)> s2
			\)> lbl
			\)> s1
			
	// FIXME: do we need this information in Coq?
	cgen-clause-to-coq:
		NewScopes(_) -> None()
	
	cgen-clause-to-coq:
		x ->
			<concat-strings; err>
				["Encountered an unexpected clause: ",
					<write-to-string> x, ". Please report."]
		where
			not(?CTrue() <+
				?CGRef(_, _) <+
				?CResolve(_, _, _) <+
				?CTypeOf(_, _, _, _) <+
				?CGenRecurse(_, _, _, _) <+
				?CGDirectEdge(_, _, _))

rules // Label

	label-pattern-to-coq:
		P() -> Ref(<p-edge>)
	
	label-pattern-to-coq:
		x ->
			<concat-strings; err>
				["Encountered an unexpected label pattern: ",
					<write-to-string> x, ". Please report."]
		where
			not(?P())

rules // Occurrence
	
	// FIXME: This naive notion of occurrence disregards namespaces, for now
	occurrence-to-coq:
		Occurrence(_, x, _) ->
			Apply(Ref(<get-occ>), <term-pattern-to-coq> x)
	
	occurrence-to-coq:
		Var(x) -> Ref(x)
	
	occurrence-to-coq:
		x ->
			<concat-strings; err>
				["Encountered an unexpected occurrence: ",
					<write-to-string> x, ". Please report."]
		where
			not(?Occurrence(_, _, _) <+
				?Var(_))

rules // Lists

	list-pattern-to-coq:
		[] -> Ref("nil")
	
	list-pattern-to-coq:
		[x|xs] ->
			<term-pattern-to-coq;
			mbind(\ x' ->
			<list-pattern-to-coq;
			mbind(\ xs' ->
			Apply(Apply(Ref("cons"), x'), xs')
			\)> xs
			\)> x

	list-pattern-to-coq:
		x ->
			<concat-strings; err>
				["Encountered term where a list was expected during",
					" list pattern generation: ", <write-to-string> x]
		where
			not(?[] <+ ?[_|_])

rules // Postification -- embeds scope/type patterns in term constructors

	postify-term-sort:
		SortNoArgs(sort_name) ->
			SortNoArgs(<conc-strings> ("Post", sort_name))
		
	postify-term-sort:
		Sort("List", [sort]) ->
			<get-sort-name;
			mbind(\ sort' ->
			SortNoArgs(<conc-strings> ("PostL", sort'))
			\)> sort

	postify-term-sort:
		x ->
			<concat-strings; err>
				["Term sort postification encountered an unexpected term sort: ",
					<write-to-string> x, ". Please report."]
		where
			not(?SortNoArgs(_) <+ ?Sort("List", [_]))

	rename-post-sort-to-post-constructor:
		x -> <conc-strings> (x, "_")
		
rules // Joining inductive definitions

	join-induc-defs:
		(name1, name2, coq) ->
			coq'
		with
			// Hoist dependent definition of Coq definition
			(inducs1, coq1) := <get-def> (name2, coq);
			name1' := <cgen-rename> name1;
			// Insert dependent definition in definition for dependee
			(
				coq' :=
					<oncetd(\
						Inductive(inducs) ->
							Inductive(<conc> (inducs, inducs1))
							where <fetch(?Induc(name1', _, _, _))> inducs \)> coq1
				<+
				coq' := <conc> (coq1, [Inductive(inducs1)])
			)
	
	get-def:
		(name1, coqdefs) -> (inducs', coqdefs')
		with
			name1' := <cgen-rename> name1;
			// Coq definitions after removing the definition for name1
			coqdefs' := 
				<filter({ inducs:
					not(?Inductive(inducs);
						<fetch(?Induc(name1', _, _, _))> inducs) })> coqdefs;
			// Binds inducs' to the definition for name1
			<alltd({ inducs:
				?Inductive(inducs);
				<fetch({x,y,z: ?Induc(name1', x, y, z) })> inducs;
				inducs' := inducs })> coqdefs

rules // Naming conventions

	cgen-rename:
		x -> <conc-strings> ("CG", x)

rules // Utility for getting first letter of string

	first-letter =
		string-as-chars(\ [x|_] -> <upper-case-chars> [x] \) <+
		?str;
		<concat-strings; err>
			["Expected a non-empty string, but was given: ",
				<write-to-string> str]

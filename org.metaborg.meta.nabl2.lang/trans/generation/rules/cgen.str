module generation/rules/cgen

imports

  libstrc

  nabl2shared
 
  signatures/common/-
  signatures/rules/-

  generation/-
  util/stratego

rules

  section-to-str:
    Rules(rule*) -> Rules(rule-str*)
    with
      rule-str* := <map(rule-to-str)> rule*

  rule-to-str:
    CGenInitRule(params,type,clause*)
      -> RDefT(<rule-name> "init",[],[<source-var>],
           Rule(<term-var>, Tuple([<params-var>, <constraint-var>]), strclause*))
    with
      (str*,constraint) := <clauses-to-str> clause*;
      params-term := <explode(injection-to-term)> params;
      if Type(type') := type then
        type-term := <explode(injection-to-term)> type';
        params-str := |[ ~<params-var> := (~params-term,~type-term) ]|;
        debug-str := Strat |[ if debug-generate-constraint then <concat-strings;debug> ["init ^(",<pp-NaBL2-Term> ~params-term,") : ",<pp-NaBL2-Term> ~type-term] end ]|
      else
        params-str := |[ ~<params-var> := ~params-term ]|;
        debug-str := Strat |[ if debug-generate-constraint then <concat-strings;debug> ["init ^ (",<pp-NaBL2-Term> ~params-term,")"] end ]|
      end;
      constraint-term := <constraint-to-term> constraint;
      constraint-str  := |[ ~<constraint-var> := ~constraint-term ]|;
      strclause* := [
        str*,
        With(params-str),
        With(constraint-str),
        With(debug-str)
      ]
 
  rule-to-str:
    CGenMatchRule(Name(name),pattern,params,type,clause*)
      -> RDefT(<rule-name> name,[],[<source-var>,<params-var>],
           Rule(pattern, <constraint-var>, strclause*))
    with
      (str*,constraint) := <clauses-to-str> clause*;
      if Type(type') := type then
        params-pattern := <explode(injection-to-pattern)> Tuple([params,type']);
        params-str := |[
          ~params-pattern := ~<params-var>
        ]|;
        metadata-str := |[
          <set-ast-params(|<Fst> ~<params-var>);
           set-ast-type(|<Snd> ~<params-var>)> ~<term-var>
        ]|;
        debug-str := |[ if debug-generate-constraint then <concat-strings;debug> [~Str(name)," [[ ",<pp-NaBL2-Term> ~<term-var>," ]] ^ (",<Fst;pp-NaBL2-Term> ~<params-var>,") : ",<Snd;pp-NaBL2-Term> ~<params-var>] end ]|
      else
        params-pattern := <explode(injection-to-pattern)> params;
        params-str := |[
          ~params-pattern := ~<params-var>
        ]|;
        metadata-str := |[
          <set-ast-params(|~<params-var>)> ~<term-var>
        ]|;
        debug-str := |[ if debug-generate-constraint then <concat-strings;debug> [~Str(name)," [[ ",<pp-NaBL2-Term> ~<term-var>," ]] ^ (",<pp-NaBL2-Term> ~<params-var>,")"] end ]|
      end;
      params-string := Str(<pp-stratego-string> params-pattern);
      guarded-params-str := |[ ~params-str <+ fatal-err(|<concat-strings> ["Cannot match expected ",~params-string," with actual ",<pp-NaBL2-Term> ~<params-var>, "."]) ]|;
      constraint-term := <constraint-to-term> constraint;
      constraint-str  := |[ ~<constraint-var> := ~constraint-term ]|;
      strclause* := [
        With(guarded-params-str),
        With(debug-str),
        str*,
        With(constraint-str),
        With(metadata-str)
      ]
 
  rule-name =
    !$[generate-constraint-[<id>]-rule]
 
rules

  clauses-to-str =
    partition(clause-to-str);
    (map(!With(<id>)),list-to-conj)

  clause-to-str:
    NewScopes(v*) -> str
    with str := <mapseq({\
                   v -> |[ ~v := <new-scope(|~<source-var>)> ~n ]|
                   with n := Str(<var-name> v)
                 \})> v*
 
  clause-to-str:
    NewVars(v*) -> str
    with str := <mapseq({\
                   v -> |[ ~v := <new-var(|~<source-var>)> ~n ]|
                   with n := Str(<var-name> v)
                 \})> v*

  clause-to-str:
    IndexSublist(list,sublist) -> str
    with str := |[ <index-sublist(|~list)> ~sublist ]|

rules
 
  list-to-conj: [] -> CTrue()
  list-to-conj: [c] -> c 
  list-to-conj: [c|cs] -> CConj(c, <list-to-conj> cs) 
 
  constraint-to-term =
    explode(explode-guard)
 
  explode-guard(e) = injection-to-term(e)
  explode-guard(e) = cgenrecurse-to-term(e)

  cgenrecurse-to-term(e):
    CGenRecurse(Name(name),v,params,type) -> App(recurse-str,v)
    with
      params-term := <e> params;
      if Type(type') := type then
        type-term := <e> type';
        recurse-arg := Tuple([params-term,type-term])
      else
        recurse-arg := params-term
      end;
      recurse-str := CallT(SVar("generate-constraint"),
          [SVar(<rule-name> name)],[<source-var>,recurse-arg])

module nabl2/runtime/solver/typechecking

imports

  runtime/editor/origins
  
  nabl2shared
  nabl2/runtime/common/-
  nabl2/runtime/prelude/-
  nabl2/runtime/solver/-
 
rules
 
  solve-constraint: (CValueOf(o,key,val),sol) -> [(sol',[])]
  where <is-ground> o;
        <is-ground> val
  with if val' := <sol-v;get(|o);get(|key)> sol then
         if <eq> (val,val') then
           !sol
         else
           msg := Message(Error(),["Value ",val," for ",o,".",key," conflicts with previously set value ",val',"."],<occurrence-index> o);
           <add-message(id|msg)> sol
         end
       else
         <sol-add-v(|o,(key,val))> sol
       end => sol'

  solve-constraint: (CTypeOf(o,ty,prio,msginfo),sol) -> [res]
  where <is-ground> o
  with t* := <sol-t> sol
     ; ( <lookup> (o, t*) => (ty',(prio',msginfo'))
       < if <priority-gt> (prio,prio') then
           !(<sol-set-t(|o,(ty,(prio,msginfo)))> sol, [CEqual(ty, ty', msginfo')])
         else
           !(sol, [CEqual(ty, ty', msginfo)])
         end
       + !(<sol-set-t(|o,(ty,(prio,msginfo)))> sol, [])
       ) => res

  priority-gt = (length,length);gt

rules

  is-op = ?TList(_) + ?TListTail(_,_) + ?TListConc(_,_)

  reduce-op(|sol): TList(xs) -> xs
    where <is-list> xs

  reduce-op(|sol): TListTail(xs,ys) -> <conc> (xs,ys)
    where <is-list> xs;
          <is-list> ys

  reduce-op(|sol): TListConc(xs,ys) -> <conc> (xs,ys)
    where <is-list> xs;
          <is-list> ys

rules

  constraint-priority: CTypeOf(_,_,_,_) -> 1
  constraint-priority: CValueOf(_,_,_) -> 1

  constraint-message: CTypeOf(o,_,_,msginfo) -> <default-message(|["Failed to get type of ",o])> msginfo
  constraint-message: CValueOf(o,key,val) -> Message(Error(),["Failed to set ",key," value of ",o],o)

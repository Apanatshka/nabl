module nabl2/runtime/analysis/generation

imports

  libspoofax/editor/completion/interface

  nabl2/shared/-
  nabl2/runtime/pp
  nabl2/runtime/analysis/-

signature

  constructors
    Params        : Term -> Args
    ParamsAndType : Term * Term -> Args

rules // top-level functions that are called during analysis

  nabl2-debug-constraint-generation-hook = fail

  nabl2--generate-constraint-init(|source) =
    ?ast;
    {| NewScope, NewVar:
	    scope-counter := <new-counter>;
	    var-counter   := <new-counter>;
	    rules( NewScope: _ -> <next-counter> scope-counter
	           NewVar:   _ -> <next-counter> var-counter
	         );
      <nabl2--generate-constraint-init-rule(|source)> ast
	  |}

  nabl2--generate-constraint-file(|source,params) =
    ?ast;
    {| NewScope, NewVar:
	    scope-counter := <new-counter>;
	    var-counter   := <new-counter>;
	    rules( NewScope: _ -> <next-counter> scope-counter
	           NewVar:   _ -> <next-counter> var-counter
	         );
      <nabl2--generate-constraint(nabl2--generate-constraint-default-rule|source,params)> ast
	  |}

rules

  nabl2--new-var(|source)   = (is-string <+ !"v") => n ; !CVar(source,$[[n]'[<NewVar;int-to-string>]])
  nabl2--new-scope(|source) = (is-string <+ !"s") => n ; !Scope(source,$[[n]'[<NewScope;int-to-string>]])

  // signatures of the generated rules
  nabl2--generate-constraint-init-rule(|source) = fail
  nabl2--generate-constraint-default-rule(|source,params) = fail

  // error throwing wrappers for recursive invocations
  nabl2--generate-constraint(s|source,params) =
    nabl2--error-no-index
 <+ nabl2--generate-constraint-placeholder(|params)
 <+ (where(!1 => x);s(|source,params)) // this is freaky, but otherwise the next call fails sometimes
 <+ nabl2--generate-constraint-missing(|params)

  nabl2--error-no-index: term -> CFalse(Message(Error(),msg,term))
    where not(nabl2--get-ast-index)
    with msg := $[Constraint generator traverses over non-AST node [<pp-NaBL2-Term> term]]

  nabl2--generate-constraint-placeholder(|params): term -> CTrue()
    where <is-SDF-placeholder> term
    with if (scopes,type) := params then
      <nabl2--set-ast-params(|scopes);nabl2--set-ast-type(|type)> term
    else
      <nabl2--set-ast-params(|params)> term
    end

  nabl2--generate-constraint-missing(|params): term -> CFalse(Message(Warning(),emsg,term))
    with if (scopes,type) := params then
      <nabl2--set-ast-params(|scopes);nabl2--set-ast-type(|type)> term;
      emsg := $[Missing constraint generation rule for [<nabl2--pp-term-sig> term] ^ [<nabl2--pp-term-sig> scopes] : _];
      cmsg := $[Missing constraint generation rule for [<nabl2--pp-term-sig> term] ^ [<pp-NaBL2-Term> scopes] : [<pp-NaBL2-Term> type]]
    else
      <nabl2--set-ast-params(|params)> term;
      emsg := $[Missing constraint generation rule for [<nabl2--pp-term-sig> term] ^ [<nabl2--pp-term-sig> params]];
      cmsg := $[Missing constraint generation rule for [<nabl2--pp-term-sig> term] ^ [<pp-NaBL2-Term> params]]
    end
    with warn(|cmsg)


  nabl2--pp-term-sig: c#(a*) -> ${[{<nabl2--pp-term-args> a*}]}
  where is-list

  nabl2--pp-term-args: a* -> [a']
  with a' := <map(!"_");separate-by(|",");concat-strings> a*

  nabl2--pp-term-sig: i -> <int-to-string>
  where is-int

  nabl2--pp-term-sig: r -> <real-to-string>
  where is-real

  nabl2--pp-term-sig: c#(a*) -> $[[c]([<nabl2--pp-term-args> a*])]



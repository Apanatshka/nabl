module nabl2/runtime/analysis/main

imports

  runtime/analysis/core
  runtime/editor/-
  runtime/index/-

  nabl2shared
 
  nabl2/runtime/analysis/-
  nabl2/runtime/common/-
  nabl2/runtime/prelude/-
  nabl2/runtime/solver/-

  signatures/nabl2/runtime/analysis/-
  signatures/nabl2/runtime/solver/-

rules

  analyze(pre):
    AnalyzeInitial(source) -> InitialResult([Params(params),Constraint(C)])
    with report-time(!$[Initializing [source]],
      (params,C) := <generate-constraint-init(|source)> source
    )


  analyze(pre):
    AnalyzeUnit(source,ast,initial) -> UnitResult(ast',[Constraint(C)])
    where not(() := ast)
    with report-time(!$[Preprocessing AST [source]],
      params := <getfirst(?Params(<id>))> initial;
      ast' := <pre;index-ast(|source)> ast
    )
    with report-time(!$[Generating constraints [source]],
      C := <generate-constraint-file(|source,params);normalize-constraint> ast'
    )

  analyze(pre):
    AnalyzeUnit(source,ast,_) -> UnitResult(ast,[Constraint(C)])
    where () := ast
    with C := CFalse(Message(Warning(),"Empty file was not parsed.",<get-ast-index> source))
 

  analyze(pre):
    AnalyzeFinal(source,initial,unit*) -> FinalResult(error*,warning*,note*,analysis)
    with report-time(!"Normalizing constraints",
      C  := <getfirst(?Constraint(<id>))> initial;
      C* := <map(getfirst(?Constraint(<id>)))> unit*;
      C' := <normalize-constraint> CConj([C|C*])
    )
    with report-time(!"Solving constraints",
    {| AnalysisTiming:
      lo* := <join(label-lt)> (<labels>,<labels>);
      sol1* := <solve-facts> [(<initial-solution>,[C'])];
      sol2* := <map(({ sol1, g:
        ?sol1;
        g := <sol-g> sol1;
        ![ InitialScopeGraph(g)
         | sol1
         ]
      },id))> sol1*;
      sol3* := <solve-constraints> sol2*;
      sol4* := <map(Fst)> sol3*; // discard constraint part
      timing := <get-analysis-timing>
    |})
    where report-time(!"Processing solutions",
    with(
      (good,bad) := <partition(not(is-erronious));(length,length)> sol4*;
      with(<debug> $[Found [<int-to-string> good] correct and [<int-to-string> bad] erronious solutions.])
    );
    where(
      sol := <Hd> sol4*
    );
    with(
      error* := <sol-e;mapv(xmlencode)> sol;
      warning* := <sol-w;mapv(xmlencode)> sol;
      note* := <sol-n;mapv(xmlencode)> sol;
      resolution := <sol-r;map((occurrence-index,Fst;occurrence-index))> sol;
      analysis := [ Constraint(C')
                  , ResolutionParams(<labels>,<labels-wf>,lo*)
                  , Timing(timing)
                  , AlternativeSolutions(<(Tl<+![]);map-with-index(id)> sol4*)
                  | sol
                  ]
    ))


  analyze(pre): ApplyAnalysis(value,solution) -> value'
    where s := <sol-s> solution
    with value' := <S-apply(is-var)> (s,value)


  analyze(pre) = warn(|"Using null analysis fallback") ; null-analysis

  report-time(msg,s) =
    where(msg := <msg>; <debug> $[>>> [msg]]);
    measure-time(s,where(<debug> $[<<< [msg] (finished in [<cputime-to-seconds;real-to-string(|2)>]s)]))

  time-analysis(s|key) =
    measure-time(s,?time');
    where(
      (count,time) := <AnalysisTiming <+ !(0,0.0)> key;
      rules(AnalysisTiming : key -> (<inc> count, <add> (time,time'))))

  get-analysis-timing =
    dr-all-keys(|"AnalysisTiming");
    map(!(<id>,<AnalysisTiming;(id,cputime-to-seconds)>))

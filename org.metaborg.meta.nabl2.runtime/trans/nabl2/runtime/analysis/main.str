module nabl2/runtime/analysis/main

imports

  runtime/analysis/core
  runtime/editor/-
  runtime/index/-

  nabl2shared
 
  nabl2/runtime/analysis/-
  nabl2/runtime/common/-
  nabl2/runtime/prelude/-
  nabl2/runtime/solver/-

  signatures/nabl2/runtime/analysis/-
  signatures/nabl2/runtime/solver/-

rules

  analyze(pre):
    AnalyzeInitial(source) -> InitialResult([Params(params),Constraint(C)])
    with <debug> $[>>> Initializing [source] <<<]
    with report-time(
      (params,C) := <generate-constraint-init(|source)> source
    )


  analyze(pre):
    AnalyzeUnit(source,ast,initial) -> UnitResult(ast',[Constraint(C)])
    where not(() := ast)
    with <debug> $[>>> Preprocessing AST [source] <<<]
    with report-time(
      params := <getfirst(?Params(<id>))> initial;
      ast' := <pre;index-ast(|source)> ast
    )
    with <debug> $[>>> Generating constraints [source] <<<]
    with report-time(
      C := <generate-constraint-file(|source,params);normalize-constraint> ast'
    )

  analyze(pre):
    AnalyzeUnit(source,ast,_) -> UnitResult(ast,[Constraint(C)])
    where () := ast
    with C := CFalse(Message(Warning(),"Empty file was not parsed.",<get-ast-index> source))
 

  analyze(pre):
    AnalyzeFinal(source,initial,unit*) -> FinalResult(error*,warning*,note*,analysis)
    with <debug> ">>> Normalizing constraints <<<"
    with report-time(
      C  := <getfirst(?Constraint(<id>))> initial;
      C* := <map(getfirst(?Constraint(<id>)))> unit*;
      C' := <normalize-constraint> CConj([C|C*])
    )
    with <debug> ">>> Solving constraints <<<"
    with report-time(
      sol-i := <initial-solution>;
      [(sol1,C1*)] := <solve-constraints-phase1> (sol-i,[C']);
      g := <sol-g> sol1;
      fr* := <resolve-all> g;
      (r1*,rn*) := <partition({\ (r,[dp]) -> (r,dp) \})> fr*;
      sol2 := <sol-set-r(|r1*)> sol1;
      lo* := <join(label-lt)> (<labels>,<labels>);
      sol3* := <solve-constraints-phase2(|rn*)> (sol2,C1*);
      sol4* := <map(Fst)> sol3*; // discard constraint part
      pre-sol := [
        Constraint(C'),
        InitialScopeGraph(g),
        InitialResolution(fr*),
        ResolutionParams(<labels>,<labels-wf>,lo*)
      ]
    )
    with <debug> ">>> Processing solutions <<<"
    where report-time(
    with(
      sol* := <qsort((sol-e;length,sol-e;length);lt)> sol4*;
      (good,bad) := <partition(not(is-erronious));(length,length)> sol*;
      with(<debug> $[Found [<int-to-string> good] correct and [<int-to-string> bad] erronious solutions.])
    );
    where(
      sol := <Hd> sol*
    );
    with(
      error* := <sol-e;mapv(xmlencode)> sol;
      warning* := <sol-w;mapv(xmlencode)> sol;
      note* := <sol-n;mapv(xmlencode)> sol;
      resolution := <sol-r;filter(not(?(_,None())));map((occurrence-index,Fst;occurrence-index))> sol;
      analysis := <concat> [
        pre-sol,
        sol,
        [AlternativeSolutions(<Tl;map-with-index(id)> sol*)]
      ]
    ))


  analyze(pre): ApplyAnalysis(value,solution) -> value'
    where s := <sol-s> solution
    with value' := <S-apply(is-var)> (s,value)


  analyze(pre) = warn(|"Using null analysis fallback") ; null-analysis

  report-time(s) = measure-time(s,where(<debug> $[Finished in [<cputime-to-seconds;real-to-string(|2)>]s]))


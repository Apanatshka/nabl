module nabl2/runtime/analysis/main

imports

  nabl2/api
  nabl2/shared/-
  nabl2/runtime/analysis/-
  nabl2/runtime/common/-
  nabl2/runtime/prelude/-
  nabl2/runtime/solver/-

  signatures/nabl2/runtime/analysis/-
  signatures/nabl2/runtime/solver/-

rules

  nabl2--analyze(pre):
    AnalyzeInitial(source) -> InitialResult([Params(params),Constraint(C)])
    with nabl2--analysis-step(!$[Initializing [source]],
      (params,C) := <nabl2--generate-constraint-init(|source)> source
    )


  nabl2--analyze(pre):
    AnalyzeUnit(source,ast,initial) -> UnitResult(ast',[Constraint(C)])
    where not(<nabl2--is-empty-ast> ast)
    with nabl2--analysis-step(!$[Preprocessing AST [source]],
      params := <getfirst(?Params(<id>))> initial;
      ast' := <pre;nabl2--index-ast(|source)> ast
    )
    with nabl2--analysis-step(!$[Generating constraints [source]],
      C := <nabl2--generate-constraint-file(|source,params);nabl2--normalize-constraint> ast'
    )

  nabl2--analyze(pre):
    AnalyzeUnit(source,ast,_) -> UnitResult(ast,[Constraint(C)])
    where <nabl2--is-empty-ast> ast
    with C := CFalse(Message(Warning(),"Empty file was not parsed.",<nabl2--get-ast-index> source))
 

  nabl2--analyze(pre):
    AnalyzeFinal(source,initial,unit*) -> FinalResult(error*,warning*,note*,analysis)
    with nabl2--analysis-step(!"Normalizing constraints",
      C  := <getfirst(?Constraint(<id>))> initial;
      C* := <map(getfirst(?Constraint(<id>)))> unit*;
      C' := <nabl2--normalize-constraint> CConj([C|C*])
    )
    with nabl2--analysis-step(!"Solving constraints",
    {| AnalysisTiming:
      lo* := <join(nabl2--label-lt)> (<nabl2--labels>,<nabl2--labels>);
      sol1* := <nabl2--solve-facts> [(<nabl2--initial-solution>,[C'])];
      sol2* := <map(({ sol1, g:
        ?sol1;
        g := <nabl2--sol-g> sol1;
        ![ InitialScopeGraph(g)
         | sol1
         ]
      },id))> sol1*;
      sol3* := <nabl2--solve-constraints> sol2*;
      sol4* := <map(Fst)> sol3*; // discard constraint part
      timing := <nabl2--get-analysis-timing;qsort(where((Snd;Snd,Snd;Snd);gt))>
    |})
    where nabl2--analysis-step(!"Processing solutions",
    with(
      (good,bad) := <partition(not(nabl2--is-erronious));(length,length)> sol4*;
      try(nabl2-debug-analysis-hook; <debug> $[Found [<int-to-string> good] correct and [<int-to-string> bad] erronious solutions.])
    );
    where(
      sol := <Hd> sol4*
    );
    with(
      error* := <nabl2--sol-e;nabl2--mapv(nabl2--xmlencode)> sol;
      warning* := <nabl2--sol-w;nabl2--mapv(nabl2--xmlencode)> sol;
      note* := <nabl2--sol-n;nabl2--mapv(nabl2--xmlencode)> sol;
      resolution := <nabl2--sol-r;map((nabl2--occurrence-index,Fst;nabl2--occurrence-index))> sol;
      analysis := [ Constraint(C')
                  , ResolutionParams(<nabl2--labels>,<nabl2--labels-wf>,lo*)
                  , Timing(timing)
                  , AlternativeSolutions(<(Tl<+![]);map-with-index(id)> sol4*)
                  | sol
                  ]
    ))


  nabl2--analyze(pre): ApplyAnalysis(value,solution) -> value'
    where s := <nabl2--sol-s> solution
    with value' := <nabl2--S-apply(nabl2--is-var)> (s,value)

  nabl2--is-empty-ast = is-tuple; ?()

  nabl2--analysis-step(msg,s) =
    where(not(nabl2-debug-analysis-hook));
    s

  nabl2--analysis-step(msg,s) =
    where(nabl2-debug-analysis-hook);
    with(msg := <msg>; <debug> $[>>> [msg]]);
    measure-time(s,with(<debug> $[<<< [msg] (finished in [<cputime-to-seconds;real-to-string(|2)>]s)]))

  nabl2--time-analysis(key,s) =
    measure-time(s,?time');
    where(
      key := <key>;
      (count,time) := <key;AnalysisTiming <+ !(0,0.0)> key;
      rules(AnalysisTiming : key -> (<inc> count, <add> (time,time'))))

  nabl2--get-analysis-timing =
    dr-all-keys(|"AnalysisTiming");
    map(!(<id>,<AnalysisTiming;(id,cputime-to-seconds)>))

module nabl2/runtime/interpreter/frame-api

imports
  nabl2/runtime/interpreter/scopegraph-api

// FIXME: All named arrows should be meta-functions, once we get better support for overloaded default arrows.

signature // The API is parameterized by some notion of value

  sorts Val

//////////////////////////////
// VANILLA FRAMES AND HEAPS //
//////////////////////////////

signature

  sorts H

  sorts Frame

  sorts FrameId

  sorts Addr constructors
    Addr : FrameId * Occurrence -> Addr

	// We could use meta-functions ...
	// But, this entails that relations get the same auxiliary entities as the default arrow!
	// This muddles the semantic definition.
	// We use arrows instead.

//  constructors
//    lookup : FrameId * H * Path --> Addr
//    get : FrameId * H * Occurrence --> Val
//    set : FrameId * H * Occurrence * Val --> H
//    scopeOfFrame : H * FrameId --> Scope
//    initFrame : Scope * Map(Label, Map(Scope, FrameId)) * Map(Occurrence, Val) --> FrameId
//    linksOf : H * FrameId --> Map(Label, Map(Scope, FrameId))
//    slotsOf : H * FrameId --> Map(Occurrence, Val)

  // Arrows are painful because we have to define tuple types manually.
  sorts OccValTuple constructors
  	OV : Occurrence * Val -> OccValTuple
  sorts ScopeLinksSlotsTuple constructors
  	SLS : Scope * Map(Label, Map(Scope, FrameId)) * Map(Occurrence, Val) -> ScopeLinksSlotsTuple
  sorts scopeOf__Meta linksOf__Meta slotsOf__Meta constructors // These constructors play no role other than determine which rule to apply
  	scopeOf : scopeOf__Meta
  	linksOf : linksOf__Meta
  	slotsOf : slotsOf__Meta

  arrows
  	FrameId, H |- Path -lookup-> Addr
  	FrameId, H |- Occurrence -get-> Val
  	FrameId    |- OccValTuple :: H -set-> Val :: H // Returns the value being assigned -- should possibly be a null or unit value 
  	FrameId, H |- scopeOf__Meta -scopeOf-> Scope
  	              ScopeLinksSlotsTuple :: H -initFrame-> FrameId :: H
  	FrameId, H |- linksOf__Meta -linksOf-> Map(Label, Map(Scope, FrameId))
  	FrameId, H |- slotsOf__Meta -slotsOf-> Map(Occurrence, Val)

  variables
    f : FrameId
    h : H

//////////////////////////////
// DEFAULT FRAMES AND HEAPS //
//////////////////////////////

signature // The API is parameterized by some operation that returns a default value for each sort

  arrows
    Type -defaultv-> Val

signature

//  constructors
//    initDefault : Scope * Map(Label, Map(Scope, FrameId)) --> FrameId
	sorts ScopeLinksTuple constructors
    SL : Scope * Map(Label, Map(Scope, FrameId)) -> ScopeLinksTuple

  arrows
  	ScopeLinksTuple :: H -initDefault-> FrameId :: H
